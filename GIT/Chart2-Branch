１．分支管理：
    未来的代码项目都是我们多人协作进行开发，但是对于我们的项目组而言，我们摸一个人的工作和别人都是互相关联的，但是我们的一旦中图提交了不完整的额代码端，难免回应项我们的同事的理解和项目的研发，但是我们的工作一旦不提交的话，难免会有丢失的风险，所以Git引入了所谓的分支的概念Branch，我们每个人在自己的工作区和分支上干活，不会影响其他人，我们最后将代码在总的分支上合并之后就OK.

２．分支：
    １．我们的分支其实上就是我们的管理型的指针，首先一开始的时候我们的整体上只有唯一的指针名叫做master分支，我们的HEAD指向的其实是master所以我们的HEAD指向了我们的当前的提交，因为我们通常的版本的切换依靠的使我们的HEAD指针，我们的HEAD指针指向哪里，我们的当前的修改就提交到我们的哪里的分支
    HEAD指针指向的就是我们的当前的位置，我们的时间线可以非常的长但是我们的HEAD指针唯一的表明了我们的当前的位置
    ２．分支管理：
        １．创建分支：
            git branch [branchname]
        ２．查看分支:
            git branch
            我们需要注意，我们查看的是当前版本库中所有的分支，并且加了星号的分支代表我们的HEAD指针指向的当前分支，也就是我们的当前的位置
        ３．切换分支:
            git checkout [branchname]
        ４．删除分支:
            git branch -d [branchname]:删除指定的分支，但是要注意，我们不能删除我们当前所在的分支，只有切换到别的分支的时候我们才可以执行该操作
        ５．合并分支:
            git merge [branchname]
            该命令用于合并制定的分支到当前的分支上，至于Fast-forward的模式我们之后会讲解
    ３．冲突处理:
        冲突处理这里我们需要注意一点，我们的merge操作是将自定的分支上的额修改和我们的当前的分支的修改进行对比，如果我们的指定的分支没有我们的当前的分支的内容新，就会报错说明，无法进行自动合并，只能执行快速合并，但是快速合并操作的要求，始终记得一点，我们都是要将我们的更新的内容,合并到我们的就得内容上的，所以指定的分支必须要新,但是
        其实说到底，我们都需要重新编辑我们的冲突文件擦除掉我们的冲突就可以了
        git log --graph:输出我们的图形化的时间线合并过程和结果
    ４．分支管理策略：
        １．fast-forward:
            快速合并，我们的快速合并仅仅只是指针的移动，我们的快速合并之后如果删除分支的话，分支信息就会丢失,因为我们只是将分支的指针合并到我们的当前的分支上，但是一旦合并之后我们的原来的分支就会销毁
        ２．--no-ff参数：
            为了避免上述的情况，我们在merge的时候可以添加参数--no-ff,这样的话，我们的意思就是生成一个新的版本(commit)，这个版本将当前的分支和制定的分支进行合并
            git merge --no-ff -m "merge a new commit" [branchname]
            上述的因为要创建一个新的版本库，所以我们的提交必须要声明一次提交的描述 -m
            为了区别我们可以采用命令:git log --graph --pretty=oneline来进行查看
        ３．实际开发:
            在实际开发的时候，我们通常都是每个人在自己的分支上干活，然后同意合并到一个分支上，这里难免会产生冲突
            因为两个人的完成的工作都不一样，所以冲突时一定的，这时候，我们因为冲突之后，会将我们的冲突的部分都写入文件，我们只需要将我们的冲突修改(把>>>>等删除掉就好)
            然后在commit就好了，这样就完成了一次多人任务合并
            如果我们需要开发新的功能的话，我们一般都是新开一个分支，然后将分支进行合并，这样的话，我们就将总实体和新功能分开来看了，新功能的一切事宜都在新功能的分支上去解决
        ４．Bug分支:
            在软件开发的时候，我们通常会遇到这样的问题，我已经进行到一个分支了，而且我的工作已经完成一半了，但是这时有一个前面分支的紧急bug需要修改
            但是我的工作还没有完成，这个半成品还不能commit到远程，这时候我们如果在回溯分支的时候，再回来，我们的员阿里的修改的痕迹就全部消失了
            这时候，为了解决这样的额问题，我们引入了stash概念
            我们stash的时候将我们的当前的修改压入栈中进行保存，但是当我们返回的时候
            git stash：保存现场
            git stash list：查看stash栈
            git stash apply [stashnumber]：回复stash
            git stash drop [stashnumber]：丢弃stash
            git stash pop [stashnumber]：弹出stash
        ５．多人协作:
            １．查看远程库:git remote / git remote -v :查看更详细的信息,fetch表示抓取于远程库，push代表有push的权限，没有看不到，说明只是自己抓下来用，不允许去提交修改
            ２．分支的推送:git push origin [branchname]
                master,dev分支都必须要和远程版本库关联病推送，bug分支只在本地修改就好
                在本地创建和远程分支对应的本地分支:git checkout -b [branchname] origin/[branchname] - 名称最好和远程版本库的分支的名称一致，方便记忆，这回收我们的pull因为本地的分支和远程的分支没有关联，导致我们的pull失败，这时候我们就需要git branch --set-upstream [branchname] origin/[branchname]关联一下
            　　如果两个人同事对一个文件进行了修改，我们如果push玩的话，会显示push失败，这时候我们就需要将远程的的分支扒下来
                git pull
                如果git pull失败很可能是没有制定要对应的分支git branch --set-upstream [branchname] origin/[branchname]
                这时候再git pull就好了，如果出现了冲突，我们就在本地将冲突进行合并，然后commit -> push一个新的分支到远程库
            ３．多人协作下的bug合并和版本管理：
                为了好理解，我们引入几个场景：
                    １．Bug:
                        先在我们的项目正在进行开发，但是我们突然发现，我们从现在起之前的所有的master分支上都有一个非常严重的bug需要紧急修复
                        很幸运，我们的bug成功的修复完毕，但是我们需要将我们的bug修复的内容都加入到主分支上所有的版本上，这里，如果选择复制粘贴的话(笑)
                        就是非常愚蠢的了
                    ２．多人协作的交互：我们的有两个开发人员A,B，AB现在已经约定过了，为了保证开发过程中分支的稳定性，只能定时的容易合并到我们的master分支上
                　      但是现在有个非常严重的问题，我们的B的工作现在急需我们的A的一项优化才能得以继续，但是我们的B只能等到合并的时候才可以急需作业了？这也是非常愚蠢
                为了解决上面两个问题以及大量的额类似问题，我们的git引入了cherry-pick功能：
                git cherry-pick commit_id:将我们制定的commit直接合并到我们的现在的分支上
                这个命令的用处在于：
                    １．我们的Bug问题，在上面的处理中，可以在出现bug的地方之前，我们开辟一个新的bug分支开始作业修复bug，修复完之后，我们将我们的最新的额bug修复的内容合并到我们的前面的所有的开发版本中，如果不用cherry-pick,我们要不就在所有的commit中全部的修改一遍这个bug，现在我们摘选出来这个固定的提交，然后都合并到我们的开发版本上，如果有冲突单独手动解决冲突，没有直接commit一个更新的修复过bug的版本就好
                    但是在这里我们需要认识到，我们的每一次的bug的处理，我们都是摘取了bug分支的一个具体的commit然后和我们的现在分支进行合并然后commit一个新的版本，注意，是又commit一个新的版本，我们最好给这个commit打一个标记从而确定好这个commit的具体位置　　－－－？引出一个小问题，为什么我们log graph的时候不会将所有的分支上的额细腻全部的显现出来，只会现实主分支和合并到主分支上的分支
                    gitk --simplify-by decoration --all 
                    ２．我们的AB问题，我们现在只需要我们将我们的A已经实现的我们的B想要的功能摘选出来cherry-pick到我们的B的分支上就好

