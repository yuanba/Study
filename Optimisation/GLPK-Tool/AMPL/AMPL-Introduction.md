## 什么是AMPL
    AMPL是一种同意的数学建模语言，摸底是为了是建模人员和编程人员的任务工作进行分离，实现我们的建模和程序的分离，实际上，我们的建模语句已经存在很多的优秀的使用的建模算法求解器，我们只需要使用AMPL语言对我们的模型进行准确 得的定义就可以自动的调用求解机实现问题的求解
   * 建立模型
   * 提供数据
   * 调用求解器语句：
     ```
     glpsol --tmlim xxx -m xxx.mod -d xxx.dat -o xxx.res > xxx.res.inf
     --tmlim表示最大运行时间 - 可能造成结果非最优
     -m制定模型文件
     -d制定数据文件
     -o制定输出结果文件
     >制定运行的信息保存文件
     ```
## 语法
### 组成
    主要的5大组成部分
 * 集
 * 参数 
 * 变量
 * 目标
 * 约束
###具体语法
####集
   * 定义：
        集是我们的建立模型设计的具体的对象的集合（这里需要强调一下我们的的集合是指我们定义的相同属性的元素的集合，比如汽车和飞机属于交通工具集合）
        我们的集合的作用就在于定义我们的对象之间的关系（二维表），实际上我们会发现这里的关系可以理解成 参数（不是变量，变量们组成的隐式关系也可以理解成隐式的二维表，只不过这个隐式的关系常用来描述我们的目标函数和我们的约束关系）
   * 语法：
        在使用我们的集合之前，我们需要对集合进行定义，定义的关键字是*set*
   * 插入语法点：
        注释，#开头的字符串都属于注释内容
        每一个语句都需要用；分号来进行结尾
   * 特殊的注释 - 索引：
        我们会发现，我们有时候定义的关系（这里的额关系我们完全可以理解成数据库中的关系）需要使用其他的序列（1....T）来具体表示一种流程，这种特殊的集合我们称为索引
####参数
* 定义：
        参数其实就是和我们的模型有关的值，我们的一次具体提供的数据决定了一组特定的针对这个模型和数据的参数，使用关键字 *param*
* 分类：
       *  简单的参数可以是一个数值
       *  大量的参数集合可以构成一个二维关系，关系由对应的集合决定的
           大多数的模型参数并不是单独的出现的，他们都会被聚合到以集合为索引的二维关系中（数组）**AMPL中总是使用{}表示引用的集合，[]表示调用的具体的参数**
           eg：
           ```
           param x{object}>=0;   #默认以x-object的关系
           param y{object,1..T}>=0;   #object-1..T的关系
           ```
* 举例：
	```param T>0 integer;```
	之后的integer特殊制定了我们的数据的类型，否则默认是浮点数
	
####变量
* 定义：
        在这里我们非常有必要来区分一下我们的额变量和我们的参数
        其实二者之间的差别非常的明显
        1.参数是针对摸一个具体的数据和模型二固定的，我们一旦提供了数据，这个提供的数据就是我们之后的参数
        2.变量是在我们的优化过程中要不断的优化的基础，我们通过不断地额修改变量的值来优化我们的目标函数，知道找到最优的变量组作为结果返回，*var*来进行定义
 * 举例
    ```
        var x{object1,object2}>=0;   #定义在我们的object1和object2上的x变量
    ```
####目标函数
* 定义：
目标可以使我们的参数和变量组成的任意的线性（这里注意必须是线性，意思是我们的表达式的任意一个组成的变量和参数都必须是和数据绑定的不是随意的变化的）表达式，使我们的优化的目标
* 举例：
```
maximize/minimize total: sum{j in object} profit[j]   #表示参数或者变量profit对object集合的所有的元素的和
```
   1  total是我们的目标的名称
   2  maximize/minimize是优化的目标，最小还是最大
   3 上例中的j和很多的程序设计语言中的作用是一致的就不在过多的描述
   
####约束
* 定义：
    * 一个约束可以使参数和变量的任意线性**等式或不等式**，模型的约束使用所有同类型的表达式为其目标
    * 约束是定义在集(和变量)之上的
 * 语法关键字：
 subject to / s.t. 
 * 举例：
 ```
 s.t. limite1 : 线性等式或者线性不等式
 s.t. limite2 {i in 1..T} : 同上
 ```
 上面的两个例子第一个代表声明一个叫做limite1的约束，约束的内容是后者
 第二个例子代表声明一个约束组（这一组约束是基于我们的索引集合的）
 
####数据
* 一旦数据值被成功地读入，所有的集成员和参数的值都变成已知的。然后AMPL翻译器能够识别目标函数和约束中的变量，确定其中的系数和常数，输出适合于算法的形式
* 严格地说，有关数据的规则并不是AMPL的一部分；每个AMPL翻译器的实现都可以接受它的创作者认为合适的任何格式的数据


###深入
####集 - 索引：
    索引集是任何大的线性规划模型的基础。大多数模型的组成都索引于这些集的某种组合之上；然而对于实际意义上的模型很少像图1-1中的P，R和1,…,T那样容易来描述。从而一个建模语言的设计不能在不同的集和索引表达式上提供太多的限制。任何的限制可能缩小模型能够方便表示的范围。
#####集
* 语法：
set
set ...within...  子集关系声明，当我们提供的数据有违反此项则拒绝执行求解器	
set name1 'description'  别名字符串定义和增加集合的描述
**我们甚至可以用..运算符构成一个索引集**
定义集的时候我们还可以使用已知的集合的运算来对集进行定义和初始化
* 复杂集：
	* 索引表达式：
	我们在索引的时候{}之后可以加：声明一段约束，从而更精确的索引我们的表中的复合约束条件的元素
	* 复合集：
	dimen定义维度，表示集合的元素是一个二元组（二元有序对），因为在有时候我们需要的数据量很小但是要分开定义的话，数据量有非常大，类似于我们的稀疏矩阵，这时候我们如果之定义一个二元组，需要的二元组我们通过数据文件读取就可以避免不必要的空间的浪费（也可以用笛卡尔积来生成）
#####参数
参数的语法我们需要特别注意的就是我们可以在模型文件的任意的位置使用check关键字来对参数进行更进一步的约束
```
check {索引} 限制表达式
```
#####特殊的运算关键字：
* if [判断表达式] then [为真] else [为假]
* exists {索引} 表达式
* forall {索引} 表达式
上述的exists相当于数学描述中的存在，forall相当于任意，这两个关键字的额用法在于，本身作为一个表达式，返回一个真假值（这个真假值取决于我们的后面的索引和约束是否成立）

###线性规划
####约束的定义：
一个现行约束是一个现行的算数表达式=，>=,<=,<开国外一个算数线性表达式
####数据参数：
* 数据文件中的参数我们无视换行
* 当我们的有多个参数都在同一个集合上进行索引，我们可以把他们压缩成一个矩阵的形式，这样和矩阵参数的定义的唯一区别就是没有参数名
```
param: init_stock cost value :=

iron 35.8 .03 .02

nickel 7.32 .025 -.01 ;
```
* 矩阵参数：
```
param units: nuts bolts washers :=

iron .79 .83 .92

nickel .21 .17 .08 ;
显而易见，这样子的和上面的定义在于这样的额定义是有参数名字的(units)
```
* 默认参数的定义：
我们通常会发先，我们的定义的参数是一种稀疏矩阵，这样的话，我们的数据文件需要秒数大量的 不必要的已知的默认值，这时候我们的参数允许我们提供默认值系统
语法的形式无非就是我们的上面的矩阵参数参数名units之后加上默认值，之后我们显示的给出我们的一些**非默认值**的参数矩阵
之后的没有在这个非默认参数矩阵上的矩阵元素和在非默认参数矩阵中使用运算符'.'描述的参数都用默认值default后面的值进行替换
