### Vim

1. 三种模式
   * 命令模式 : 使用命令操作删除赋值字符等等
   * 输入模式 : 在输入模式下，我们可以编辑文本
   * 最后行命令模式 : 在最后行可以一些重要相关命令

### Gcc

1. 效果 : 编译的代码质量好效果高，速度快

2. 基本操作

   ```bash
   gcc -v    # 输出版本信息
   gcc [option] file_name    # 根据制定的选项生成可执行文件

   # 可执行文件 .out
   # 预处理文件默认输出到标准输出 .i / .ii
   # 汇编文件 .s
   # 目标文件 .o
   # 源代码 .c / .cpp
   ```

3. 操作步骤

   1. 预处理

      这一步分析各种宏定义，`#define`,`include`,`#if`等宏定义并带入，使用cpp程序执行该步骤

   2. 编译

      **产生汇编语言**，因为我们生产的汇编代码通常都立即调用，所以这一步结果不保存在文件中,使用ccl程序进行编译工作

   3. 汇编

      一汇编语言作为输入，输出目标文件，调用as程序进行汇编工作

   4. 链接

      该阶段，将所有的目标文件放在可执行文件中的适当位置上，包括程序引用的函数，使用ld程序执行，输入是很多的目标文件，输出我们的可执行文件

4. 重要参数

   * -c : **只生成目标文件**，不进行链接工作,生成.o文件
   * -o filename : 保存结果文件，结果可以是任何的文件类型，gcc选择输出即可 
   * -g : 开启调试模式
   * -O : 对代码进行便以优化，默认是等级2的优化[0,1,2,3]，优化和调试不兼容

### Linux C的开发过程

基本过程

1. 输入程序，保存源程序
2. 执行编译器，生成目标文件(.o)
3. 执行链接器，链接各自的目标文件，生成可执行文件

### make / makefile

1. 在进行Linux下的开发的时候，可以讲一个大的系统分为很多的子系统，每一个子系统又是由很多的模块构成的，**模块之间的协作协调使用make进行协调**

   重新编译之后，我们可以保证我们的程序石红是由最新的模块构成的

2. makefile文件中描述了文件之间的联系关系，提供了更新每个文件的命令

3. 文件更新 -> 编译更新生成新的目标文件 -> 新的目标文件链接生成新的可执行文件

4. 举例

   ```makefile
   a.out : module1.o module2.o     # 定义我们的可执行文件a.out和两个目标文件的关系，只要目标文件中的一个更新了就要重新调用gcc进行编译
       gcc module1.o module2.o -o a.out
   module1 : module1.c module1.h    # 定义了目标文件module1.o是由我们的一个.c和一个.h文件编译成的
       gcc -c module1.c
   module2 : module2.c module2.h    # 同上
       gcc -c module2.o
   ```

5. `make`

   1. make是`GNU`的套件组，用来对我们的makefile文件执行生成对应的可执行文件

   2. make按照makefile的语法要求，只对需要更新编译的文件进行重新编译操作

   3. 如果没有特殊的指定make -f参数指定的makefile文件，默认在当前目录下查找makefile文件

   4. 工作状态

      ```bash
      make [options] [define] [target]     # 对target执行options参数并采用相关的宏定义,target表示需要维护重新编译的目标
      ```

   5. 参数

      * -f : 制定makefile文件
      * -p : 打印出makefile 文件中的所有的宏定义和秒数内部规则的相关行
      * -i : 忽略Linux下的错误继续执行
      * -s : 执行但显示执行状况
      * -n : 测试makefile文件正确性的时候执行，不执行文件只是按照执行顺序出要执行的命令
      * -d : debug模式

6. makefile文件格式

   ```makefile
   目标 : 依赖项列表
       对应的执行命令(gcc / ... ,前面要有一个Tab符号的留白)
       
   # 可以使用#作为注释，make将会跳过这个步骤，实在行过长开一使用\作为行为续行
   # make默认讲所有的输出显示的打印，在相关行前加入@可以便面输出该行
   # 为了保证make的正确执行，尽量保证makefile在和源文件相同的目录下
   ```

   ​

   ​

   ​