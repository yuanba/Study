# why?

1. 没有程序语言是完美的,只存在适合和不适合的程序设计语言
2. 我们甚至可以在程序设计和开发的时候将部分功能放在shell中去完成，可以很快速的调试程序的主要部分，因为shell可以很快速的将某些部分做的很好
3. 组合，组合，组合！将打的任务分割成小的模块组合起来
4. 不适合使用shell的场合:
   1. 资源密集型任务
   2. 大型数学操作
   3. 跨平台移植
   4. 复杂应用
   5. 安全
   6. 组件模块有连锁的依赖性
   7. 多维数组支持
   8. 图形界面需要



# Begin

1.调用一个脚本

我们编写的脚本文件最简单的理解就是命令的集合，提供了很高的方便性和可定制型

例子总结:

```shell
cd /var/log   # log is a dir,gave the file 1 2.
cat /dev/null > 1
cat /dev/null > 2
echo "1 and 2 has been cleaned up!"
```

以/dev/null设备打开文件可以实现文件的**清除**操作

例子总结：

* 每个脚本最好都写上exit并加上相应的返回数字，目的是让我们之后的echo语句可以判断程序的执行情况
* \#\!意味着我们的执行需要一个解释器，后面跟随解释这段脚本的解释器的路径，可能是shell也可能是一个程序设计语言，也可能是一个命令程序，解释器从头开始执行脚本语句，如果路径错误，返回**'command not found'**错误
* 只有开头的#!才有用，之后的会默认当成注释
* \#\!/bin/rm表示调用rm程序，执行删除效果，这里的小技巧是，将该行写在脚本的开头我们可以实现自删除(实际上，该脚本什么都还没来得及做就被删除了)
* \#\!/bin/more甚至可以实现一个自启动的帮助文档，只要我们给他加上**可执行权限**

2.使用一个脚本

启动方式

* sh / bash / chmod +x && ./xxx

* 测试完成的脚本，我们可以放在/usr/local/bin下就可以让所有的用户使用该脚本

  使用的方式就是直接输入脚本的名称

* 这里要强调一点，如果脚本在当前目录的话,我们不可以输入scriptname去执行它，因为这个脚本并没有在我们的当前的$PATH环境变量中，我们的所有的直接输入的命令都需要在环境变量中去查找(上述的/usr/local/bin在环境变量中)为了安全考虑，当前目录不在环境变量中,所以我们在当前目录或者其他的不在环境变量中的目录只能使用相对路径或者绝对路径的形式去执行，也就是我们常见的

  ./xxx.sh

3.练习题

```shell
#!/bin/bash
x=`date +%Y%m%d\ %H:%M:%S`
y=`who`
z=`uptime`
echo $x > /home/...
echo $y >> /home/...
echo $z >> /home/...
```

