# 特殊字符汇总

用在脚本或者我们的命令行中的特殊的字符

* \#

  * \#\!表示解释器指明

  * 注释：空白行之后，每一行之后，命令无法写在注释的后面

  * 特定的场合下有特别的意思

    ```shell
    # 数制转化10进制
    $((2#110)) # 输出 6
    $((16#110)) # 输出 272	
    ```

* ;

  命令分隔符，允许我们在一行中描述多个命令

  有些情况下需要转义

* ;;

  case语句的break标记

* .

  1.等同于source命令，执行从path中扒取可执行文件

  2.正则模式匹配，表示任意字符

  3.隐藏文件标记,正常的ls命令无法获取，需要l参数

  4.当前工作目录

* “ / '

  双引号阻止大部分的转义字符，单引号阻止全部的特殊符号

* /

  文件路径分隔符号

  除法操作符

* ``

  命令替换符号

  \`command\`的形式会将命令的输出复制到一个变量中，配合($)可以快速的分配我们的数组空间

* :

  空命令，相当于我们的pass语句，改命令的退出号码是0

  等同于true命令，不执行任何一件事，但是表示语句成功返回，退出号码是０

  执行死循环

  ```shell
  while :
  do
  	echo "Here is a no-end loop!"
  done

  while true
  do
      echo "Here is a no-end loop!"
  done
  ```

  执行清空文件操作

  ```
  : > file   # 清空文件,该命令是一个內建命令，不会开启子进程
  ```

* !

  取反操作符，会翻转命令的退出码

* \*

  通配符，可以作为文件名的匹配，匹配给定目录下的任何文件，只匹配之后的任意字符串

  正则表达式中表示任意的个数的字符

  在\$(())/\$[]中，可以使用\*\*表示幂操作,\\\*表示执行乘号操作

* ?

  通配符，表示匹配单个字符，正则表达式中表示匹配一个字符或者０个字符

* \$

  引用变量

  正则表达式中表示行结束，所谓的向后匹配

  * ${}:引用
  * ${n} :ｎ表示数字，可以执行命令行或者函数的参数的调用操作
  * $$:当前进程PID
  * $?：上一条命令执行的退出码
  * $#:命令行或者函数参数的个数
  * \$* / \$@:表示所有的参数，但是二者有区别，区别体现在引号上，在有引号的情况下，后者还是分开输出满是前者变成整体输出
  * $!：运行在后台的最后一个命令的PID
  * $_：之前执行命令的最后一个值

* ()命令组

  括号中的命令将会当做一个sub shell来运行,因此在括号内的变量在我们之后的shell语句中是不可调用的

  初始化数组，空格分开，还可以使用($)的语句来将一个字符串强制按照默认的IFS转化成数组

* ｛｝扩展

  一个命令可能会对在{}内部的逗号分割的文件组产生作用，比如说

  在这种情况下，不允许空白，除非被转义

  ```shell
  cat 1 2 3 > 4
  cat {1,2,3} > 4

  cp 1.{txt,backup}   # 1.txt -> 1.backup
  cp {1,2}   # 1 -> 2
  ```

* ｛｝代码块

  创建一个匿名的函数，但是和普通的函数还有区别

  但是创建的函数实在本地运行的，所以我们函数内部的操作只要不是设计局部变量的都会对外部的变量存在影响

  **可以将一段的代码整合一起输出到我们的一个文件当中去，并且这不会开启一个新的shell**

* [] / [[]]

  条件测试，这是shell中test命令的一部分

  正则表达式的一部分，选择匹配

  数组的元素的选取

* (())

  实现整数的扩展，可以在其内加上整数表达式

* 重定向符号

  * \>　重定向内容到文件，文件不存在先建立文件，存在会覆盖

  * &>  重定向标准输出和标准错误到文件

  * \>&2  重定向标准输出到标准错误

  * \>\> 追加型重定向，不存在会创建，存在追加

  * \<>  打开文件的重定向输入和输出模式，打开读写模式，文件不存在先创建

  * \<< 用在here document中的重定向

    ```shell
    cat <<string > a
    ....
    ....
    ....
    <<string
    # 将文本块重定向到ａ文件中
    awk '{...}' <<string
    ...
    ...
    <<string
    ```

  * \<<<　字符串重定向

    可以将部分的字符串按照该防范重定向到我们的制定的程序中，比如awk,bc中去执行相应的步骤，类似与重定向标准输入

  * \< , >

    字符串变量的文本比较。注意要使用在[[]]比较运算符中

* ｜

  管道，分析前面的命令，并将前面的标准输出作为后面的标准输入，产生命令链

  如果管道中的一个命令长生了异常，或者中途失败的话，这个管道会过早的种植这种行为叫做broken pipe并发送一个信号

  ？？作为子进程的管道是没有办法影响我们的父进程的变量的

* \>|

  强制重定向，强制覆盖一个现存的文件

* || / &&

  或与逻辑操作符号，在一个条件测试语句中

* ＆

  后台运行命令，在一个脚本中，任何一个命令和循环都可以运行在后台中

  ```shell
  while true
  do
  echo "something"
  done > file &
  # 后台执行命令并将结果重定向到文件中，可以用watch命令查看文件的变化
  ```

  我们需要小心，因为在实际中，我们如果将后台运行的命令写入脚本的话，会导致执行顺序的不同，因为有些脚本在后台运行的时候会被挂起

* -

  选项前缀，在所有的命令中，想要使用参数我们都必须要使用-符号指明参数

  ```shell
  (cd /source/directory && tar -cvf - .) | (cd /dest/directory && tar -xpvf -)
  # 这里注意添加的v会把消息准确的送到标准输出上
  # 在这里，我们的-符号表示标准输出和标准输入
  # 首先是管道前面的命令组：-表示输出经由管道，打包当前目录
  # 之后是管道后面的命令组：-表示解压的对象经由管道,p参数保持文件的属性不变

  tar -cvf - . > file.tar   
  #　上述的命令也是用-符号，表示标准输出，然后不使用管道，使用重定向将打包的内容添加到指定的tar文件中
  ```

  \-还不可以表示成$OLDPWD环境变量，表示的是cd -切换到上一个目录上

  在需要一个文件名的位置上，-重定向到输出上stdout，而不是从文件中接收输入

  还可以使用-配合grep实现将文件的某一段

  ```shell
  cat file1 | diff file2 # Error diff命令之后缺少文件
  cat file1 | diff file2 -  #　将上一个命令的标准输出作为第二个文件参数
  ```

  ​

* ~

  1.HOME目录,不同于变量，不需要使用\$就可以实现替换操作

  ```shell
  echo ~user   #　现实用户的主目录
  echo ~ # 现实当前用户的主目录
  command  ~/   #　对当前用户的主目录进行相应的处理，比如cd ,ls
  ```

* 控制字符(ctrl字符)

  * ctrl - b:光标退一格
  * ctrl - c:终止**作业**
  * ctrl - d:
    * EOF:文件终止
    * exit:从shell中登出
  * ctrl - q:从terminal中回复标准输出
  * ctrl - z:暂停前台作业病放在后台进行挂起

  ​

  ​

  ​

  ​